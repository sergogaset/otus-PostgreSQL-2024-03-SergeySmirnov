## 1. Создание и подготовка кластера 
Создал ВМ со следующими параметрам:  
**ОЗУ**: 4Гб  
**ЦП**: 2  
**SSD**: 24Гб  
Установил **PostgreSQL 15**:  

![scrin-1](./images/scrin-1.jpg)

## 2. Настройте выполнение контрольной точки раз в 30 секунд
В конфигурационном файле **postgresql.conf** в параметре **checkpoint_timeout** указал значение в 30 секунд:

![scrin-2](./images/scrin-2.jpg)

Остальные параметры оставил по-умолчанию. Далее перезапустил кластер командами:  
```
pg_ctlcluster 15 main stop
pg_ctlcluster 15 main start
```
Кластер перезапущен успешно:  

![scrin-3](./images/scrin-3.jpg)

## 3. 10 минут c помощью утилиты pgbench подавайте нагрузку
Создал и инициализировал тестовую БД командами:
```
create database testix;
sudo -u postgres pgbench -i testix
```
Параметры инициализации оставил стандартные. Результаты:  

![scrin-4](./images/scrin-4.jpg)

Далее запустил **pgbench** со следующими параметрами:  
```
sudo -u postgres pgbench -c 100 -j 2 -P 30 -T 600 testix
```
Количество подключений указал максимально доступное в текущей конфигурации и 2 потока пол количеству процессоров. Также открыл вторую сессию для мониторинга и нагрузки и размера WAL.  
Видно, что нагрузка есть:  

![scrin-5](./images/scrin-5.jpg)

Также видно, что пишутся новые WAL-сегменты:  

![scrin-6](./images/scrin-6.jpg)

Ожидаю окончанию бэнчмарка...  
Результаты следующие:  

![scrin-7](./images/scrin-7.jpg)

## 4. Измерьте, какой объем журнальных файлов был сгенерирован за это время. Оцените, какой объем приходится в среднем на одну контрольную точку.

Сначала объем WAL вычислял грубым способом, а именно ставил большое значение параметра **checkpoint_timeout** и запускал **pgbench**. Далее с помощью команды:  
```
ls -lah /var/lib/postgresql/15/main/pg_wal/
```
Смотрел общий объем папки **pg_wal** и вычитал по принципу: стало - было.  
Но данный способ не подходит при значении параметра **checkpoint_timeout** в 30 секунд, так как чекпоинты выполняются часто и объем WAL держится на минимальном значении из параметра **min_wal_size**, в моем случае по-умолчанию 80 Мб.  
Поэтому решил использовать способ, показанный в лекции. Для этого сначала определили текущий **LSN** командами:  
```
SELECT pg_current_wal_lsn();
SELECT pg_current_wal_insert_lsn();
```
В моем случае значения были следующими:  

![scrin-8](./images/scrin-8.jpg)

Они одинаковы, а значит все изменения были записаны на диск.  
Зафиксировал значение - 0/57268070.  
Далее снова запустил pgbench с теми же параметрами. Результаты:  

![scrin-9](./images/scrin-9.jpg)

Далее подключиился к **psql** и посмотрел текущий **LSN**:

![scrin-10](./images/scrin-10.jpg)

Зафиксировал значение - 0/7D204400.  
Далее с помощью запроса:  
```
SELECT '0/7D204400'::pg_lsn - '0/57268070'::pg_lsn;
```
Узнал разницу **LSN** в байтах. Результат:  

![scrin-11](./images/scrin-11.jpg)

Результат в байтах составил 637125520 или 607,61 Мб. За 10 минут было сделано 20 контрольных точек, то есть, если считать нагрузку равномерной, то на 1 чекпоинт приходится 637125520 / 20 = 31856276 байт или 30,38 Мб.

## 5. Проверьте данные статистики: все ли контрольные точки выполнялись точно по расписанию. Почему так произошло?

Для анализа выполнения контрольных точек включил их логирование. Для этого в файл **postgresql.conf** добавил следующие параметры:  

![scrin-12](./images/scrin-12.jpg)

После этого перезапустил кластер и сразу запустил утилиту **pgbench** с такими же настройками.  
После выполнения бэнчмарка остановил кластер и выгрузил логи по чекпоинтам следующей командой:  
```
cat /var/lib/postgresql/15/main/log/postgresql-2024-07-13.log | grep 'checkpoint' > /home/checkpoint_log.txt
```
Содержимое файла:  

![scrin-13](./images/scrin-13.jpg)

Из него видно, что чекпоинты действительно начинали делаться каждые 30 секунд и завершались спустя 27 секунд после начала. То есть согласно параметру **checkpoint_completion_target = 0.9**. Из лога также видно, что на один чекпоинт приходится примерно 30Мб журналов, что подтверждает вычисления из прошлого задания. В целом, никаких сбоев в расписании выполнения чекпоинтов не увидел. Единственный чекпоинт, который выполнился не по расписанию был чекпоинт, созданный перед остановкой кластера.

## 6. Сравните tps в синхронном/асинхронном режиме утилитой pgbench. Объясните полученный результат

Для начала выполнил бэнчмарк в синхронном режиме и получил следующие результаты:  

![scrin-14](./images/scrin-14.jpg)

Зафиксировал значение **tps** - 1080.270768.  
Далее выключил синхронный режим. Для этого в конфигурационном файле **postgresql.conf** и нашел параметр **synchronous_commit** и указал значение **off**:  

![scrin-15](./images/scrin-15.jpg)

После этого перезапустил кластер и запустил **pgbench** с теми же параметрами. Результаты:  

![scrin-16](./images/scrin-16.jpg)

**tps** повысился с 1080.270768 до 1575.560223, то есть примерно в 1,5 раза.

Данное поведение связано с тем, что в режиме off ожидание сброса WAL на диск отсутствует, клиент узнает о завершении транзакции раньше, чем в синхронном режиме, следовательно, возрастает скорость обработки транзакций, но гарантия сохранности каждой транзакции не обеспечивается.

## 7. Создайте новый кластер с включенной контрольной суммой страниц. Создайте таблицу. Вставьте несколько значений. Выключите кластер. Измените пару байт в таблице. Включите кластер и сделайте выборку из таблицы. Что и почему произошло? как проигнорировать ошибку и продолжить работу?

Текущий кластер не удалял, с 12 версии можно включать и на уже созданном кластере утилитой **pg_checksums**.  
Сначала проверил, что контрольные суммы выключены командой:  
```
SHOW data_checksums;
```
Результат:  

![scrin-17](./images/scrin-17.jpg)

Далее остановил кластер командой:  
```
pg_ctlcluster 15 main stop
```
И включил контрольные суммы для данного кластера командой:  
```
sudo -u postgres /usr/lib/postgresql/15/bin/pg_checksums -e /var/lib/postgresql/15/main
```
Результат:  

![scrin-18](./images/scrin-18.jpg)

Далее запустил кластер командой:  
```
pg_ctlcluster 15 main start
```
И снова проверил включены ли контрольные суммы:  

![scrin-19](./images/scrin-19.jpg)

Как видно, контрольные суммы для данного кластер успешно включены.  
Далее создал базу данных **checksums** для теста. Создал в ней таблицу **test** и добавил в нее 100 строк следующими командами:  
```
CREATE DATABASE checksums;
\c checksums
INSERT INTO test SELECT s.id FROM generate_series(1,100) AS s(id);
SELECT * FROM test limit 10;
```
Результат:  

![scrin-20](./images/scrin-20.jpg)

Далее узнал физическое расположение таблицы командой:  
```
SELECT pg_relation_filepath('public.test');
```
Результат:  

![scrin-22](./images/scrin-22.jpg)

Далее выключил кластер:  

![scrin-21](./images/scrin-21.jpg)

С помощью утилиты **hexdump** посмотрел содержимое файла таблицы:  

![scrin-23](./images/scrin-23.jpg)

Далее с помощью утилиты **hexedit** изменил пару байт. Вот что получилось:

![scrin-24](./images/scrin-24.jpg)

Далее запустил кластер и сделал выборку из таблицы:  

![scrin-25](./images/scrin-25.jpg)

Ошибка произошла потому что расчитанная контрольная сумма 62812 не равна ожидаемой 50165, то есть данные были изменены или повреждены.  
Чтобы игнорировать подобные ошибки необходимо активировать параметр **ignore_checksum_failure** в конфигурационном файле **postgresql.conf**. Добавил этот параметр в конец файла:  

![scrin-26](./images/scrin-26.jpg)

Далее перезапустил кластер и проверил, что параметр активирован:  

![scrin-27](./images/scrin-27.jpg)

И попробовал сделать выборку из таблицы:  

![scrin-28](./images/scrin-28.jpg)

Теперь ошибка игнорируется, но, судя по выборке, данные все таки были повреждены.